

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VMware VCF 9 Upgrade Planner</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <!-- CDN for html2canvas to capture HTML elements as images -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <!-- CDN for jsPDF to generate PDF documents -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    /* Clarity-like Base Styles */
    body {
      font-family: 'Inter', sans-serif; /* Clarity often uses Open Sans or similar, but Inter is close */
      background-color: #f0f3f5; /* Light gray background, common in Clarity */
      color: #333; /* Darker text for readability */
    }
    .container {
      max-width: 1200px;
    }
    
    /* Component Card Styles (Clarity-like) */
    .component-card {
      cursor: grab;
      border: 1px solid #d9e1e8; /* Lighter, subtle border */
      border-radius: 6px; /* Slightly less rounded corners for Clarity feel */
      padding: 12px;
      margin: 8px;
      background: #ffffff;
      transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      display: flex;
      align-items: center;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08); /* Subtle shadow */
    }
    .component-card:hover {
      transform: translateY(-2px) scale(1.01); /* Lift and slightly enlarge on hover */
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.12); /* More pronounced shadow on hover */
      cursor: grabbing;
    }
    .component-card h3 {
      font-weight: 600; /* Semi-bold */
      color: #333; /* Dark text */
    }
    .component-card select {
      border: 1px solid #b3c2ce; /* Clarity-like border for selects */
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 0.875rem;
      background-color: #fcfdfe; /* Very light background for select */
      cursor: pointer;
      color: #333;
    }

    /* Drop Zone Styles (Clarity-like) */
    .drop-zone {
      min-height: 250px;
      border: 2px dashed #a3d0ed; /* Lighter blue dashed border */
      border-radius: 6px;
      padding: 20px;
      background: #f5fafd; /* Very light blue background */
      display: flex;
      flex-wrap: wrap;
      align-content: flex-start;
      gap: 10px;
      transition: background-color 0.3s ease-in-out, border-color 0.3s ease-in-out;
    }
    .drop-zone.drag-over {
      background: #e0f2fe; /* Slightly darker blue on drag over */
      border-color: #007CBB; /* Clarity blue solid border */
    }
    .dropped-component-card {
      background-color: #eaf4fb; /* Light blue for dropped cards */
      border: 1px solid #a3d0ed; /* Matching border */
      border-radius: 4px;
      padding: 8px 12px;
      display: flex;
      align-items: center;
      font-size: 0.9rem;
      font-weight: 500;
      color: #00568c; /* Darker blue text */
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    .dropped-component-card .remove-btn {
      margin-left: 10px;
      background: none;
      border: none;
      color: #ef4444; /* Standard red for remove */
      cursor: pointer;
      font-size: 0.8rem;
      padding: 2px 5px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    .dropped-component-card .remove-btn:hover {
      background-color: #fecaca; /* Light red hover */
    }

    /* Chart Container Styles */
    #chart-container {
      min-height: 450px;
      border: 1px solid #d9e1e8; /* Subtle border */
      border-radius: 6px;
      background: #ffffff;
      padding: 20px;
      position: relative;
      display: flex;
      justify-content: center;
      /* Removed align-items: flex-end; to allow chart to fill from top */
      overflow: hidden;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
    }
    #chart-container.loading::after {
      content: 'Generating Upgrade Path...';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #56687a; /* Clarity gray text */
      font-size: 1.1rem;
      font-weight: 500;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    canvas {
      max-width: 100%;
      height: 100%; /* Ensure canvas takes full available height */
    }
    .fallback-list {
      list-style: decimal;
      padding-left: 20px;
      margin-top: 10px;
    }

    /* Info Box Styles (Clarity-like) */
    .info-box {
      background-color: #eaf4fb; /* Light blue info background */
      border: 1px solid #a3d0ed; /* Matching border */
      border-radius: 6px;
      padding: 15px;
      margin-top: 20px;
      color: #00568c; /* Darker blue text */
      font-size: 0.95rem;
      line-height: 1.5;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    .info-box a {
        color: #007CBB; /* Clarity blue for links */
        text-decoration: underline;
    }
    .info-box a:hover {
        color: #00568c;
    }

    /* Message Box Styles (Clarity-like) */
    .message-box {
        position: fixed;
        top: 20px;
        right: 20px;
        background-color: #333; /* Keep dark for general messages, or use Clarity's toast colors */
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
    }
    .message-box.show {
        opacity: 1;
    }

    /* Button Styles (Clarity-like Primary Button) */
    .show-path-btn {
        background-color: #007CBB; /* Clarity Primary Blue */
        color: white;
        padding: 12px 24px;
        border: none;
        border-radius: 6px; /* Slightly less rounded */
        font-size: 1.1rem;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15); /* More pronounced shadow */
        /* Removed display: block and auto margins for flexbox */
    }
    .show-path-btn:hover {
        background-color: #00568c; /* Darker blue on hover */
        transform: translateY(-1px); /* Subtle lift */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    .show-path-btn:active {
        transform: translateY(0);
        box-shadow: 1px 2px rgba(0, 0, 0, 0.1);
    }

    /* Reset Button Style (Clarity-like Secondary Button) */
    .reset-btn {
        background-color: #6a7c8a; /* Clarity Gray/Secondary Button */
        color: white;
        padding: 12px 24px;
        border: none;
        border-radius: 6px;
        font-size: 1.1rem;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        /* Removed display: block and auto margins for flexbox */
    }
    .reset-btn:hover {
        background-color: #4a5568; /* Darker gray on hover */
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    .reset-btn:active {
        transform: translateY(0);
        box-shadow: 1px 2px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body class="bg-gray-100">
  <div class="container mx-auto p-6">
    <h1 class="text-3xl font-bold text-center mb-6 text-gray-800">VMware VCF 9 Upgrade Planner</h1>
    <p class="text-center text-gray-600 mb-8">Drag and drop existing VMware components to visualize a potential upgrade path to VMware Cloud Foundation 9.0</p>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
      <div class="bg-white p-4 rounded-lg shadow-md">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">Component Selection</h2>
        <div id="components-palette" class="flex flex-wrap -m-2">
          </div>
      </div>
      <div class="bg-white p-4 rounded-lg shadow-md">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">Your Current Environment</h2>
        <div id="customer-environment" class="drop-zone">
          <p class="text-gray-500 text-center w-full">Drag components here to build your current environment.</p>
        </div>
        <div class="flex justify-center gap-4 mt-6">
            <button id="show-path-button" class="show-path-btn">Show Upgrade Path</button>
            <button id="reset-button" class="reset-btn">Reset</button>
            <button id="export-pdf-button" class="show-path-btn">Export to PDF</button>
        </div>
      </div>
    </div>
    <div class="grid grid-cols-1 md:col-span-2 gap-6 mt-6"> 
      <div class="bg-white p-4 rounded-lg shadow-md col-span-1 md:col-span-2"> 
        <h2 class="text-xl font-semibold mb-4 text-gray-700">Upgrade Path</h2>
        <div id="chart-container" class="relative">
          <canvas id="flowchart"></canvas>
        </div>
        <div id="overview" class="mt-4 info-box">
          <p class="text-gray-700">Drop components into "Your Current Environment" and click "Show Upgrade Path".</p>
        </div>
      </div>
    </div>
  </div>

  <div id="message-box" class="message-box"></div>

  <script>
    // Register Chart.js datalabels plugin
    Chart.register(ChartDataLabels);

    // Custom plugin to draw arrowheads on lines
    const arrowHeadsPlugin = {
        id: 'arrowHeads',
        afterDatasetDraw(chart, args, options) { // Use afterDatasetDraw for specific dataset control
            // Ensure args.dataset exists before accessing its properties
            if (!args.dataset || args.dataset.label !== 'Connections') {
                return; // Only draw for the 'Connections' dataset
            }

            const { ctx, chartArea, scales } = chart;
            const connectionsDataset = args.dataset;
            const nodesDataset = chart.data.datasets.find(ds => ds.label === 'Nodes');
            // Get nodeRadius. It can be a single value or an array. If array, take the first value.
            const nodeRadius = nodesDataset && nodesDataset.pointRadius ? 
                                (Array.isArray(nodesDataset.pointRadius) ? nodesDataset.pointRadius[0] : nodesDataset.pointRadius) : 
                                12; 
            const datalabelsPadding = 10; // Assuming default padding from datalabels plugin options
            const effectiveNodeRadius = nodeRadius + datalabelsPadding; // Account for node radius and datalabels padding

            ctx.save();
            ctx.strokeStyle = connectionsDataset.borderColor;
            ctx.lineWidth = connectionsDataset.borderWidth; 
            ctx.fillStyle = connectionsDataset.borderColor; // Fill arrow with line color

            // Iterate through connections. Each connection has two points in the data array.
            // So we iterate by 2.
            for (let i = 0; i < connectionsDataset.data.length; i += 2) {
                const startPoint = connectionsDataset.data[i];
                const endPoint = connectionsDataset.data[i + 1];

                // Get pixel coordinates from scales
                const startX = scales.x.getPixelForValue(startPoint.x);
                const startY = scales.y.getPixelForValue(startPoint.y);
                const endX = scales.x.getPixelForValue(endPoint.x);
                const endY = scales.y.getPixelForValue(endPoint.y);

                // Calculate angle of the line
                const angle = Math.atan2(endY - startY, endX - startX);

                // Calculate the position for the arrowhead tip, slightly before the end node
                // Offset by effectiveNodeRadius to ensure it sits outside the node's visual boundary.
                const arrowTipX = endX - effectiveNodeRadius * Math.cos(angle);
                const arrowTipY = endY - effectiveNodeRadius * Math.sin(angle);

                // Arrowhead properties
                const arrowHeadLength = 10; // Length of the arrowhead wings
                const arrowHeadWidth = 6;  // Width of the arrowhead base (half-width from center)

                ctx.beginPath();
                ctx.moveTo(arrowTipX, arrowTipY);
                ctx.lineTo(
                    arrowTipX - arrowHeadLength * Math.cos(angle - Math.PI / 6), // PI/6 is 30 degrees
                    arrowTipY - arrowHeadLength * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    arrowTipX - arrowHeadLength * Math.cos(angle + Math.PI / 6),
                    arrowTipY - arrowHeadLength * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }
    };

    // Register the custom arrowhead plugin
    Chart.register(arrowHeadsPlugin);


    // Function to show custom messages
    function showMessage(message, type = 'info') {
        const msgBox = document.getElementById('message-box');
        msgBox.textContent = message;
        msgBox.className = 'message-box show'; // Reset and show
        if (type === 'error') {
            msgBox.style.backgroundColor = '#dc2626'; // Red for error
        } else {
            msgBox.style.backgroundColor = '#333'; // Default dark
        }
        setTimeout(() => {
            msgBox.classList.remove('show');
        }, 3000); // Hide after 3 seconds
    }

    // Helper function to parse and compare versions
    // Handles versions like '7.0 U3', '8.0', '8.0U1', '9.0'
    function compareVersions(v1, v2) {
        // Normalize versions for comparison (e.g., '8.0U1' -> '8.0.1', '7.0 U3' -> '7.0.3')
        const normalize = (version) => {
            return version.replace(/ U(\d+)/, '.$1').split('.').map(Number);
        };

        const n1 = normalize(v1);
        const n2 = normalize(v2);

        for (let i = 0; i < Math.max(n1.length, n2.length); i++) {
            const num1 = n1[i] || 0;
            const num2 = n2[i] || 0;
            if (num1 > num2) return 1; // v1 is greater
            if (num1 < num2) return -1; // v1 is smaller
        }
        return 0; // versions are equal
    }


    // Component data with icons and versions
    const components = [
      { name: 'vCenter', versions: ['7.0 U3', '8.0', '8.0U1', '8.0U2', '8.0U3', '9.0'], icon: '<i class="fas fa-server"></i>' },
      { name: 'ESX', versions: ['7.0 U3', '8.0', '8.0U1', '8.0U2', '8.0U3', '9.0'], icon: '<i class="fas fa-microchip"></i>' },
      { name: 'vSAN', versions: ['7.0 U3', '8.0', '8.0U1', '8.0U2', '8.0U3', '9.0'], icon: '<i class="fas fa-hdd"></i>' },
      { name: 'NSX', versions: ['4.0.0.1', '4.0.1.1', '4.1.0.0', '4.1.1.0', '4.1.2.0', '4.2.0.0', '4.2.1.0'], icon: '<i class="fas fa-network-wired"></i>' },
      { name: 'TKGS for vSphere', versions: [], icon: '<i class="fas fa-cubes"></i>' },
      { name: 'Aria Automation', versions: ['8.18.0', '8.18.1'], icon: '<i class="fas fa-robot"></i>' },
      { name: 'Aria Operations', versions: ['8.17.1','8.17.2','8.18.0', '8.18.1'], icon: '<i class="fas fa-chart-line"></i>' },
      { name: 'Aria Operations for Logs', versions: ['8.16.x', '8.18.x'], icon: '<i class="fas fa-file-alt"></i>' },
      { name: 'Aria Operations for Networks', versions: ['6.12.x', '6.13.x', '6.14.x'], icon: '<i class="fas fa-project-diagram"></i>' },
      { name: 'SDDC Manager', versions: ['4.x', '5.x'], icon: '<i class="fas fa-cloud"></i>' },
      { name: 'VxRail Manager', versions: ['7.x', '8.x'], icon: '<i class="fas fa-server"></i>' }
    ];

    // Populate components palette
    const palette = document.getElementById('components-palette');
    components.forEach(component => {
      const card = document.createElement('div');
      card.className = 'component-card';
      card.draggable = true;
      let versionSelectHtml = '';
      if (component.versions && component.versions.length > 0) {
        versionSelectHtml = `
          <select class="version-select p-1 border rounded" data-component-name="${component.name}">
            ${component.versions.map(v => `<option value="${v}">${v}</option>`).join('')}
          </select>
        `;
      }
      card.innerHTML = `
        ${component.icon}
        <h3 class="text-sm font-medium ml-2 mr-2">${component.name}</h3>
        ${versionSelectHtml}
      `;
      card.dataset.component = component.name;
      palette.appendChild(card);

      // Add change listener for ESX version select
      if (component.name === 'ESX') {
        const esxVersionSelect = card.querySelector('.version-select');
        if (esxVersionSelect) {
          esxVersionSelect.addEventListener('change', (e) => {
            const selectedEsxVersion = e.target.value;
            const dropZone = document.getElementById('customer-environment');
            const vsanCard = Array.from(dropZone.children).find(el => el.dataset.component === 'vSAN');
            
            if (vsanCard) {
              const vsanComponent = components.find(c => c.name === 'vSAN');
              if (vsanComponent && vsanComponent.versions.includes(selectedEsxVersion)) {
                vsanCard.dataset.version = selectedEsxVersion;
                // Update the displayed text for vSAN
                const spanElement = vsanCard.querySelector('span');
                if (spanElement) {
                    spanElement.textContent = `vSAN ${selectedEsxVersion}`;
                }
                showMessage(`vSAN version automatically set to ${selectedEsxVersion} to match ESX.`, 'info');
              } else if (vsanComponent) {
                showMessage(`Selected ESX version ${selectedEsxVersion} is not available for vSAN. Please update vSAN manually if needed.`, 'warning');
              }
            }
          });
        }
      }

      card.addEventListener('dragstart', (e) => {
        const versionSelect = card.querySelector('.version-select');
        const selectedVersion = versionSelect ? versionSelect.value : ''; // Get version only if select exists
        e.dataTransfer.setData('text/plain', JSON.stringify({
          component: component.name,
          version: selectedVersion
        }));
        card.style.opacity = '0.4'; // Visual feedback for dragging
      });

      card.addEventListener('dragend', () => {
        card.style.opacity = '1'; // Reset opacity after drag
      });
    });

    // Customer environment drop zone
    const dropZone = document.getElementById('customer-environment');
    
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('drag-over');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('drag-over');
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('drag-over');

      const data = JSON.parse(e.dataTransfer.getData('text/plain'));
      const existing = Array.from(dropZone.children).find(el => el.dataset.component === data.component);
      if (existing) {
        showMessage(`Component "${data.component}" already added. Remove it first.`, 'error');
        return;
      }

      // Special handling for vSAN drop: auto-set version if ESX is present
      if (data.component === 'vSAN') {
        const esxInDropZone = Array.from(dropZone.children).find(el => el.dataset.component === 'ESX');
        if (esxInDropZone) {
          const esxVersion = esxInDropZone.dataset.version;
          const vsanComponentDef = components.find(c => c.name === 'vSAN');
          if (vsanComponentDef && vsanComponentDef.versions.includes(esxVersion)) {
            data.version = esxVersion; // Set vSAN's version to match ESX
            showMessage(`vSAN version automatically set to ${esxVersion} to match ESX.`, 'info');
          } else {
            showMessage(`ESX version ${esxVersion} is not a valid version for vSAN. Please ensure compatibility.`, 'warning');
          }
        }
      }

      const item = document.createElement('div');
      item.className = 'dropped-component-card';
      item.dataset.component = data.component;
      item.dataset.version = data.version;
      // Display version only if it's not empty
      const displayVersion = data.version ? ` ${data.version}` : '';
      item.innerHTML = `
        <span>${data.component}${displayVersion}</span>
        <button class="remove-btn" title="Remove"><i class="fas fa-times-circle"></i></button>
      `;
      dropZone.appendChild(item);
      showMessage(`Added "${data.component}${displayVersion}" to your environment.`);

      item.querySelector('.remove-btn').addEventListener('click', () => {
        item.remove();
        showMessage(`Removed "${data.component}${displayVersion}" from your environment.`);
        // No immediate update to flowchart
      });

      // No immediate update to flowchart
    });

    // "Show Upgrade Path" button functionality
    const showPathButton = document.getElementById('show-path-button');
    showPathButton.addEventListener('click', () => {
        const droppedComponents = getDroppedComponents();
        if (droppedComponents.length === 0) {
            showMessage("Please drag components to 'Your Current Environment' first.", 'error');
            return;
        }
        updateFlowchart();
    });

    // "Reset" button functionality
    const resetButton = document.getElementById('reset-button');
    resetButton.addEventListener('click', () => {
        const dropZone = document.getElementById('customer-environment');
        const overviewDiv = document.getElementById('overview');
        const chartContainer = document.getElementById('chart-container');
        const ctx = document.getElementById('flowchart').getContext('2d');

        // Clear dropped components
        dropZone.innerHTML = '<p class="text-gray-500 text-center w-full">Drag components here to build your current environment.</p>';
        
        // Destroy existing chart if it exists and clear canvas
        if (window.flowchartInstance) {
            window.flowchartInstance.destroy();
            window.flowchartInstance = null; // Clear reference
        }
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        // Reset overview text
        overviewDiv.innerHTML = '<p class="text-gray-700">Drop components into "Your Current Environment" and click "Show Upgrade Path".</p>';
        
        // Ensure loading state is removed
        chartContainer.classList.remove('loading');

        showMessage('Environment and upgrade path cleared.');
    });


    // Helper to get dropped components
    function getDroppedComponents() {
      return Array.from(dropZone.children).map(el => ({
        name: el.dataset.component,
        version: String(el.dataset.version || '')
      })).filter(c => c.name);
    }

    // Flowchart rendering and dynamic scenario generation
    function updateFlowchart() {
      const ctx = document.getElementById('flowchart').getContext('2d');
      const chartContainer = document.getElementById('chart-container');
      const overviewDiv = document.getElementById('overview');
      const droppedComponents = getDroppedComponents();

      if (droppedComponents.length === 0) {
        overviewDiv.innerHTML = '<p class="text-gray-700">Drop components into "Your Current Environment" and click "Show Upgrade Path".</p>';
        if (window.flowchartInstance) {
          window.flowchartInstance.destroy();
          ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        }
        chartContainer.classList.remove('loading');
        return;
      }

      chartContainer.classList.add('loading');

      // Check for core components unless VxRail or SDDC Manager are present
      const hasVCenter = droppedComponents.some(c => c.name === 'vCenter');
      const hasESX = droppedComponents.some(c => c.name === 'ESX');
      const hasVxRail = droppedComponents.some(c => c.name === 'VxRail Manager');
      const hasSDDCManager = droppedComponents.some(c => c.name === 'SDDC Manager');

      if ((!hasVCenter || !hasESX) && !hasVxRail && !hasSDDCManager) {
          showMessage("Please select vCenter and ESX. These are core components required for VCF 9 upgrade paths in real-life scenarios. VxRail and SDDC Manager are exceptions.", 'error');
          // Clear previous chart and overview if components are missing
          if (window.flowchartInstance) {
              window.flowchartInstance.destroy();
              ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
          }
          overviewDiv.innerHTML = '<p class="text-red-600">Please select vCenter and ESX. These are core components required for VCF 9 upgrade paths in real-life scenarios. VxRail and SDDC Manager are exceptions.</p>';
          chartContainer.classList.remove('loading');
          return; // Stop execution if validation fails
      }

      // Validation for ESX and vSAN version matching
      const esxComponentInDropZone = droppedComponents.find(c => c.name === 'ESX');
      const vsanComponentInDropZone = droppedComponents.find(c => c.name === 'vSAN');

      if (esxComponentInDropZone && vsanComponentInDropZone && esxComponentInDropZone.version !== vsanComponentInDropZone.version) {
          showMessage("ESX and vSAN versions must match. Please adjust the versions in 'Your Current Environment'.", 'error');
          if (window.flowchartInstance) {
              window.flowchartInstance.destroy();
              ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
          }
          overviewDiv.innerHTML = '<p class="text-red-600">ESX and vSAN versions must match. Please adjust the versions in \'Your Current Environment\'.</p>';
          chartContainer.classList.remove('loading');
          return; // Stop execution if validation fails
      }

      // New validation: vCenter version must be equal to or higher than ESX version (unless VxRail/SDDC Manager)
      if (hasVCenter && hasESX && !hasVxRail && !hasSDDCManager) {
          const vCenterComponent = droppedComponents.find(c => c.name === 'vCenter');
          const esxComponent = droppedComponents.find(c => c.name === 'ESX');

          if (vCenterComponent && esxComponent) {
              const vCenterVersion = vCenterComponent.version;
              const esxVersion = esxComponent.version;

              // If vCenter version is strictly less than ESX version, show error
              if (compareVersions(vCenterVersion, esxVersion) < 0) { 
                  showMessage("vCenter version must be equal to or higher than ESX version. Please adjust versions.", 'error');
                  if (window.flowchartInstance) {
                      window.flowchartInstance.destroy();
                      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                  }
                  overviewDiv.innerHTML = '<p class="text-red-600">vCenter version must be equal to or higher than ESX version. Please adjust versions.</p>';
                  chartContainer.classList.remove('loading');
                  return; // Stop execution if validation fails
              }
          }
      }


      let tempNodes = [];
      let tempConnections = [];
      let details = ''; // Initialize details here, will be populated conditionally
      let nextNodeId = 1;
      let lastNodeId = 0;
      const verticalSpacing = 80;
      const nodeXPosition = 200;

      const validDroppedComponents = droppedComponents.filter(c => c && typeof c.name === 'string' && typeof c.version === 'string');

      const hasNSX = validDroppedComponents.some(c => c.name === 'NSX');
      const hasTKGSForVSphere = validDroppedComponents.some(c => c.name === 'TKGS for vSphere');
      const hasAria = validDroppedComponents.some(c => c.name.startsWith('Aria'));
      const hasAriaAutomation = validDroppedComponents.some(c => c.name === 'Aria Automation');
      const hasAriaOperationsForLogs = validDroppedComponents.some(c => c.name === 'Aria Operations for Logs');
      const hasAriaOperationsForNetworks = validDroppedComponents.some(c => c.name === 'Aria Operations for Networks');
      
      const hasOldVSphere = validDroppedComponents.some(c => (c.name === 'vCenter' || c.name === 'ESX') && c.version.startsWith('7.'));
      const hasOldVSAN = validDroppedComponents.some(c => c.name === 'vSAN' && c.version.startsWith('7.'));
      const hasOldNSX = validDroppedComponents.some(c => c.name === 'NSX' && (c.version.startsWith('3.') || c.version.startsWith('4.0.') || c.version.startsWith('4.1.0.') || c.version.startsWith('4.1.1.') || c.version.startsWith('4.1.2.') || c.version.startsWith('4.2.0.')));
      const hasVxRail7x = validDroppedComponents.some(c => c.name === 'VxRail Manager' && c.version.startsWith('7.'));
      const hasVxRail8x = validDroppedComponents.some(c => c.name === 'VxRail Manager' && c.version.startsWith('8.'));

      // New flags for components already at 9.0
      const isVCenter90 = validDroppedComponents.some(c => c.name === 'vCenter' && c.version.startsWith('9.'));
      const isESX90 = validDroppedComponents.some(c => c.name === 'ESX' && c.version.startsWith('9.'));
      const isVSAN90 = validDroppedComponents.some(c => c.name === 'vSAN' && c.version.startsWith('9.'));
      const hasVSAN = validDroppedComponents.some(c => c.name === 'vSAN');


      // Start Node (logical first step, will be visually at the top)
      const currentEnvLabel = `Current: ${validDroppedComponents.map(c => `${c.name} ${c.version}`).join(', ')}`;
      tempNodes.push({ id: nextNodeId++, label: currentEnvLabel, type: 'start', x: nodeXPosition });
      lastNodeId = tempNodes[tempNodes.length - 1].id;

      // --- Determine the primary upgrade path and set nodes/connections/details ---
      if (hasSDDCManager) {
          tempNodes.push({ id: nextNodeId++, label: 'Perform VCF Pre-Upgrade Checks', type: 'action', x: nodeXPosition });
          tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
          lastNodeId = tempNodes[tempNodes.length - 1].id;
          details = `**Existing VCF Environment Upgrade Path:**<br>
          This path is for environments already running VMware Cloud Foundation. The upgrade is managed through SDDC Manager.
          <ol class="list-decimal list-inside ml-4">
            <li>**Perform VCF Pre-Upgrade Checks:** Conduct comprehensive health checks of your VCF environment, including network validation, DNS/NTP synchronization, and ensure all necessary backups of SDDC Manager and component VMs are completed. Consult the <a href="https://techdocs.broadcom.com/us/en/vmware-cis/vcf/vcf-9-0-and-later/9-0/planning-and-preparation.html" target="_blank" class="text-blue-600 hover:underline">VCF 9.0 Planning and Preparation Guide</a> for a complete pre-check list.</li>`;

          const sddcManagerComponent = validDroppedComponents.find(c => c.name === 'SDDC Manager');
          const sddcManagerVersion = sddcManagerComponent ? sddcManagerComponent.version : '';
          const requiresIntermediateVCF5x = sddcManagerVersion.startsWith('4.');

          if (requiresIntermediateVCF5x) {
              tempNodes.push({ id: nextNodeId++, label: 'Upgrade to VCF 5.x SDDC Manager', type: 'action', x: nodeXPosition }); 
              tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
              lastNodeId = tempNodes[tempNodes.length - 1].id;
              tempNodes.push({ id: nextNodeId++, label: 'Upgrade VCF 5.x Management Domain', type: 'action', x: nodeXPosition });
              tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
              lastNodeId = tempNodes[tempNodes.length - 1].id;
              details += `<li>**Upgrade to VCF 5.x:** VCF environments with SDDC Manager 4.x require an intermediate upgrade to VCF 5.x (which includes vCenter 8.0, vSAN 8.0, NSX 4.1.x) before proceeding to VCF 9.0. Ensure hardware compatibility for ESX 8.0.</li>`; 
          }
          
          tempNodes.push({ id: nextNodeId++, label: 'Upgrade SDDC Manager to 9.0', type: 'action', x: nodeXPosition });
          tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
          lastNodeId = tempNodes[tempNodes.length - 1].id;
          details += `<li>**Upgrade SDDC Manager to 9.0:** Update the SDDC Manager appliance itself to the VCF 9.0 version.</li>`;
          
          tempNodes.push({ id: nextNodeId++, label: 'Upgrade VCF 9.0 Management Domain (vCenter, NSX, ESX, vSAN to 9.0)', type: 'action', x: nodeXPosition });
          tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
          lastNodeId = tempNodes[tempNodes.length - 1].id;
          details += `<li>**Upgrade VCF 9.0 Management Domain:** Upgrade the core components of the management domain (vCenter, NSX Manager, ESX hosts, vSAN) to their VCF 9.0 compatible versions.</li>`;
          
          tempNodes.push({ id: nextNodeId++, label: 'Upgrade VCF 9.0 Workload Domains (Optional, to 9.0)', type: 'action', x: nodeXPosition });
          tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
          lastNodeId = tempNodes[tempNodes.length - 1].id;
          details += `<li>**Upgrade VCF 9.0 Workload Domains (Optional):** System-defined and customer-created workload domains can be upgraded sequentially after the management domain.</li>`;
          
          tempNodes.push({ id: nextNodeId++, label: 'Perform VCF Post-Upgrade Validations', type: 'action', x: nodeXPosition });
          tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
          lastNodeId = tempNodes[tempNodes.length - 1].id;
          details += `<li>**Perform VCF Post-Upgrade Validations:** Verify the health and functionality of all VCF components and integrated services.</li>
          </ol>
          Always refer to the specific <a href="https://techdocs.broadcom.com/us/en/vmware-cis/vcf/vcf-9-0-and-later/9-0/release-notes/vmware-cloud-foundation-90-release-notes.html" target="_blank" class="text-blue-600 hover:underline">VCF 9.0 Release Notes</a> and <a href="https://techdocs.broadcom.com/us/en/vmware-cis/vcf/vcf-9-0-and-later/9-0/deployment.html" target="_blank" class="text-blue-600 hover:underline">VCF 9.0 Deployment Guide (which includes upgrade info)</a> for your exact version and detailed procedures.`;
          if (hasTKGSForVSphere || hasAria) {
              details += ` Existing TKGS for vSphere and Aria Suite components will be upgraded as part of the VCF Bill of Materials (BOM) or re-integrated post-upgrade.`;
          }
      } else if (hasVxRail) { // VxRail is present, but no SDDC Manager
          if (hasVxRail7x) {
              tempNodes.push({ id: nextNodeId++, label: 'Upgrade VxRail Manager to 8.x', type: 'action', x: nodeXPosition });
              tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
              lastNodeId = tempNodes[tempNodes.length - 1].id;
              tempNodes.push({ id: nextNodeId++, label: 'VCF 9.0 Upgrade Not Available', type: 'end', x: nodeXPosition });
              tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
              lastNodeId = tempNodes[tempNodes.length - 1].id;
          } else if (hasVxRail8x) {
              tempNodes.push({ id: nextNodeId++, label: 'VCF 9.0 Upgrade Not Available', type: 'end', x: nodeXPosition });
              tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
              lastNodeId = tempNodes[tempNodes.length - 1].id;
          }
          // Set generic VxRail message for details
          details = `**VxRail Manager Upgrade Path:**<br>
                     Please consult official Dell EMC documentation for VxRail upgrade paths. Currently, there is no direct upgrade path from VxRail Manager 7.x or 8.x to VCF 9.0. VxRail 7.x can upgrade to 8.x.`;

          // Add the specific red text note for VxRail
          details += `<p class="text-red-600 font-bold mt-4">Currently No upgrade to VCF 9 for VXRAIL systems.</p>`;

      } else { // Standalone environment (no SDDC Manager, no VxRail)
          details = `**Standalone Environment to VCF 9.0 Convergence/Import Path:**<br>
          This path is for converting existing standalone VMware vSphere, vSAN, and NSX environments into a VCF 9.0 deployment.
          <ol class="list-decimal list-inside ml-4">
            <li>**Perform Pre-Upgrade Checks (Compatibility, Health):** Ensure your current standalone components meet VCF 9.0 compatibility requirements. Perform health checks, backups of all components (vCenter, NSX, etc.), and thoroughly review the <a href="https://interopmatrix.broadcom.com/Upgrade" target="_blank" class="text-blue-600 hover:underline">Product Interoperability Matrix</a> for supported upgrade paths.</li>`;

          const isImportPath = hasNSX; // If NSX is present, it's an Import path, otherwise Converge

          if (isImportPath) {
              details += `<li>**Import Path (NSX Present):** This path is for environments with existing NSX. Your vSphere components (vCenter, ESX, vSAN) must be on a compatible 8.x version to be imported.</li>`;

              if (hasOldVSphere || hasOldVSAN) {
                  tempNodes.push({ id: nextNodeId++, label: 'Upgrade vCenter/ESX/vSAN to 8.x (for Import)', type: 'action', x: nodeXPosition });
                  tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                  lastNodeId = tempNodes[tempNodes.length - 1].id;
                  details += `<li>**Upgrade vCenter/ESX/vSAN to 8.x:** If your vCenter, ESX hosts, or vSAN are currently on version 7.x, you must first upgrade them to a compatible 8.x version for import.</li>`;
              }
              // NSX upgrade steps for import path
              const nsxComponent = validDroppedComponents.find(c => c.name === 'NSX');
              if (nsxComponent) {
                  const nsxVersion = nsxComponent.version;
                  const requiresIntermediateNSX421 = ['4.0.0.1', '4.0.1.1', '4.1.0.0', '4.1.1.0', '4.1.2.0', '4.2.0.0', '4.2.1.0'].includes(nsxVersion);

                  if (requiresIntermediateNSX421) {
                      tempNodes.push({ id: nextNodeId++, label: 'Upgrade NSX to 4.2.1.0 (for Import)', type: 'action', x: nodeXPosition });
                      tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                      lastNodeId = tempNodes[tempNodes.length - 1].id;
                      details += `<li>**Upgrade NSX to 4.2.1.0:** If your NSX-T Data Center is on version ${nsxVersion}, you must first upgrade it to 4.2.1.0 as an intermediate step for import.</li>`;
                  }
                  // Always upgrade to 9.0.0 if NSX is present and supported for import
                  tempNodes.push({ id: nextNodeId++, label: 'Upgrade NSX to 9.0.0 (for Import)', type: 'action', x: nodeXPosition });
                  tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                  lastNodeId = tempNodes[tempNodes.length - 1].id;
                  details += `<li>**Upgrade NSX to 9.0.0:** Upgrade your NSX environment to a version compatible with VCF 9.0 for import.</li>`;
              }
              
              // Aria Automation specific upgrade paths for Import Path
              const ariaAutomationComponent = validDroppedComponents.find(c => c.name === 'Aria Automation');
              if (ariaAutomationComponent) {
                  if (ariaAutomationComponent.version === '8.18.0') {
                      tempNodes.push({ id: nextNodeId++, label: 'Upgrade Aria Automation to 8.18.1', type: 'action', x: nodeXPosition });
                      tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                      lastNodeId = tempNodes[tempNodes.length - 1].id;
                      details += `<li>**Upgrade Aria Automation to 8.18.1:** If your Aria Automation is at 8.18.0, you must upgrade to 8.18.1 as an intermediate step.</li>`;
                  }
                  if (ariaAutomationComponent.version === '8.18.0' || ariaAutomationComponent.version === '8.18.1') {
                      tempNodes.push({ id: nextNodeId++, label: 'Upgrade Aria Automation to 9.0.0', type: 'action', x: nodeXPosition });
                      tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                      lastNodeId = tempNodes[tempNodes.length - 1].id;
                      details += `<li>**Upgrade Aria Automation to 9.0.0:** Upgrade your Aria Automation to version 9.0.0.</li>`;
                  }
              }

              // Aria Operations for Networks specific upgrade paths for Import Path
              const ariaOperationsForNetworksComponent = validDroppedComponents.find(c => c.name === 'Aria Operations for Networks');
              if (ariaOperationsForNetworksComponent) {
                  if (ariaOperationsForNetworksComponent.version === '6.12.x') {
                      tempNodes.push({ id: nextNodeId++, label: 'Upgrade Aria Operations for Networks to 6.14.x', type: 'action', x: nodeXPosition });
                      tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                      lastNodeId = tempNodes[tempNodes.length - 1].id;
                      details += `<li>**Upgrade Aria Operations for Networks to 6.14.x:** If your Aria Operations for Networks is at 6.12.x, you must upgrade to 6.14.x as an intermediate step.</li>`;
                  }
                  if (ariaOperationsForNetworksComponent.version === '6.12.x' || ariaOperationsForNetworksComponent.version === '6.13.x' || ariaOperationsForNetworksComponent.version === '6.14.x') {
                      tempNodes.push({ id: nextNodeId++, label: 'Upgrade Aria Operations for Networks to 9.0.0', type: 'action', x: nodeXPosition });
                      tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                      lastNodeId = tempNodes[tempNodes.length - 1].id;
                      details += `<li>**Upgrade Aria Operations for Networks to 9.0.0:** Upgrade your Aria Operations for Networks to version 9.0.0.</li>`;
                  }
              }

              // Aria Operations for Logs specific upgrade paths for Import Path
              if (hasAriaOperationsForLogs) {
                  tempNodes.push({ id: nextNodeId++, label: 'Transition to VCF Operations for Logs 9.0', type: 'action', x: nodeXPosition });
                  tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                  lastNodeId = tempNodes[tempNodes.length - 1].id;
                  details += `<li>**Transition to VCF Operations for Logs 9.0:** If you have Aria Operations for Logs, you will need to transition to the VCF Operations for Logs 9.0 solution. This is typically a migration or redeployment process, as direct in-place upgrades are often not supported for this component when moving to a new VCF major version. Refer to the specific <a href="https://docs.vmware.com/en/VMware-Cloud-Foundation/services/rn/vmware-vrealize-log-insight-for-vcf-release-notes/index.html" target="_blank" class="text-blue-600 hover:underline">VCF Operations for Logs documentation</a> for detailed transition procedures.</li>`;
              }


              tempNodes.push({ id: nextNodeId++, label: 'Import as VI Workload Domain into VCF 9.0', type: 'action', x: nodeXPosition });
              tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
              lastNodeId = tempNodes[tempNodes.length - 1].id;
              details += `<li>**Import as VI Workload Domain into VCF 9.0:** For NSX-enabled standalone environments, the recommended path is to upgrade components to compatible 8.x vSphere and 9.0 NSX, then import them as a VI workload domain into an existing VCF 9.0 management domain. This preserves your NSX configuration. See the <a href="https://techdocs.broadcom.com/us/en/vmware-cis/vcf/vcf-9-0-and-later/9-0/building-your-private-cloud-infrastructure/working-with-workload-domains/import-an-existing-vcenter-to-create-a-workload-domain.html" target="_blank" class="text-blue-600 hover:underline">VCF 9.0 Import Existing vCenter Guide</a> for detailed steps.</li>`;

          } else { // Converge Path (No NSX)
              details += `<li>**Converge Path (No NSX):** This path is for environments without NSX. Your vSphere components (vCenter, ESX, vSAN) must be upgraded to 9.0 for convergence.</li>`;

              // Intermediate upgrade to 8.x for vCenter/ESX/vSAN if any are 7.x
              const needsIntermediate8xUpgrade = hasOldVSphere || hasOldVSAN;
              if (needsIntermediate8xUpgrade) {
                  let upgradeIntermediateLabel = 'Upgrade ';
                  let upgradeIntermediateDetail = `<li>**Upgrade `;

                  const needsVCenter7to8 = validDroppedComponents.some(c => c.name === 'vCenter' && c.version.startsWith('7.'));
                  const needsESX7to8 = validDroppedComponents.some(c => c.name === 'ESX' && c.version.startsWith('7.'));
                  const needsVSAN7to8 = validDroppedComponents.some(c => c.name === 'vSAN' && c.version.startsWith('7.'));

                  if (needsVCenter7to8) {
                      upgradeIntermediateLabel += 'vCenter';
                      upgradeIntermediateDetail += 'vCenter';
                  }
                  if (needsESX7to8) {
                      if (upgradeIntermediateLabel !== 'Upgrade ') { upgradeIntermediateLabel += '/'; upgradeIntermediateDetail += '/'; }
                      upgradeIntermediateLabel += 'ESX';
                      upgradeIntermediateDetail += 'ESX hosts';
                  }
                  if (needsVSAN7to8) {
                      if (upgradeIntermediateLabel !== 'Upgrade ') { upgradeIntermediateLabel += '/'; upgradeIntermediateDetail += '/'; }
                      upgradeIntermediateLabel += 'vSAN';
                      upgradeIntermediateDetail += 'vSAN';
                  }
                  upgradeIntermediateLabel += ' to 8.x (Intermediate)';
                  upgradeIntermediateDetail += ` are currently on version 7.x, you must first upgrade them to a compatible 8.x version.</li>`;

                  tempNodes.push({ id: nextNodeId++, label: upgradeIntermediateLabel, type: 'action', x: nodeXPosition });
                  tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                  lastNodeId = tempNodes[tempNodes.length - 1].id;
                  details += upgradeIntermediateDetail;
              }
              
              // Conditional upgrade for vCenter to 9.0
              if (validDroppedComponents.some(c => c.name === 'vCenter')) { // Only consider if vCenter is dropped
                  if (!isVCenter90) {
                      tempNodes.push({ id: nextNodeId++, label: 'Upgrade vCenter to 9.0 (for Converge)', type: 'action', x: nodeXPosition });
                      tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                      lastNodeId = tempNodes[tempNodes.length - 1].id;
                      details += `<li>**Upgrade vCenter to 9.0:** Upgrade your vCenter to version 9.0 as required for the VCF 9.0 convergence.</li>`;
                  } else {
                      details += `<li>**vCenter is already 9.0:** Your vCenter is already at a VCF 9.0 compatible version.</li>`;
                  }
              }

              // Conditional upgrade for ESX Hosts & vSAN to 9.0
              const needsESXUpgrade = hasESX && !isESX90;
              const needsVSANUpgrade = hasVSAN && !isVSAN90;

              if (needsESXUpgrade || needsVSANUpgrade) {
                  let label = 'Upgrade ';
                  let detailText = '<li>**Upgrade ';
                  if (needsESXUpgrade) {
                      label += 'ESX Hosts';
                      detailText += 'ESX hosts';
                  }
                  if (needsESXUpgrade && needsVSANUpgrade) {
                      label += ' & ';
                      detailText += ' & ';
                  }
                  if (needsVSANUpgrade) {
                      label += 'vSAN';
                      detailText += 'vSAN';
                  }
                  label += ' to 9.0 (for Converge)';
                  detailText += ` to versions compatible with VCF 9.0.</li>`;

                  tempNodes.push({ id: nextNodeId++, label: label, type: 'action', x: nodeXPosition });
                  tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                  lastNodeId = tempNodes[tempNodes.length - 1].id;
                  details += detailText;
              } else if (hasESX || hasVSAN) { // If ESX or vSAN are present and already 9.0
                  let already90Details = '<li>';
                  if (hasESX && isESX90) {
                      already90Details += '**ESX Hosts are already 9.0:** Your ESX hosts are already at a VCF 9.0 compatible version.';
                  }
                  if (hasESX && isESX90 && hasVSAN && isVSAN90) {
                      already90Details += ' '; // Space between phrases
                  }
                  if (hasVSAN && isVSAN90) {
                      already90Details += '**vSAN is already 9.0:** Your vSAN is already at a VCF 9.0 compatible version.';
                  }
                  already90Details += '</li>';
                  details += already90Details;
              }


              if (hasTKGSForVSphere || hasAria) {
                 tempNodes.push({ id: nextNodeId++, label: 'Deploy/Upgrade Aria Suite & TKGS for vSphere to VCF 9.0 compatible versions (if applicable)', type: 'action', x: nodeXPosition });
                 tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                 lastNodeId = tempNodes[tempNodes.length - 1].id;
                 
                 let tkgsAriaDetails = `<li>**Deploy/Upgrade Aria Suite & TKGS for vSphere to VCF 9.0 compatible versions (if applicable):** `;
                 if (isVCenter90 && isESX90 && (!validDroppedComponents.some(c => c.name === 'vSAN') || isVSAN90)) {
                     tkgsAriaDetails += `Since your vSphere components are already at 9.0, TKGS for vSphere and Aria Suite components will primarily require deployment or re-integration to align with VCF 9.0.`;
                 } else {
                     tkgsAriaDetails += `Deploy or upgrade your Aria Suite products and TKGS for vSphere components to versions compatible with VCF 9.0.`;
                 }
                 details += tkgsAriaDetails + `</li>`;
              }
              // Handle Aria Operations for Networks specific upgrade paths (before VCF Installer)
              const ariaOperationsForNetworksComponent = validDroppedComponents.find(c => c.name === 'Aria Operations for Networks');
              if (ariaOperationsForNetworksComponent) {
                  if (ariaOperationsForNetworksComponent.version === '6.12.x') {
                      tempNodes.push({ id: nextNodeId++, label: 'Upgrade Aria Operations for Networks to 6.14.x', type: 'action', x: nodeXPosition });
                      tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                      lastNodeId = tempNodes[tempNodes.length - 1].id;
                      details += `<li>**Upgrade Aria Operations for Networks to 6.14.x:** If your Aria Operations for Networks is at 6.12.x, you must upgrade to 6.14.x as an intermediate step.</li>`;
                  }
                  if (ariaOperationsForNetworksComponent.version === '6.12.x' || ariaOperationsForNetworksComponent.version === '6.13.x' || ariaOperationsForNetworksComponent.version === '6.14.x') {
                      tempNodes.push({ id: nextNodeId++, label: 'Upgrade Aria Operations for Networks to 9.0.0', type: 'action', x: nodeXPosition });
                      tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                      lastNodeId = tempNodes[tempNodes.length - 1].id;
                      details += `<li>**Upgrade Aria Operations for Networks to 9.0.0:** Upgrade your Aria Operations for Networks to version 9.0.0.</li>`;
                  }
              }

              // Aria Automation specific upgrade paths for Converge Path
              const ariaAutomationComponent = validDroppedComponents.find(c => c.name === 'Aria Automation');
              if (ariaAutomationComponent) {
                  if (ariaAutomationComponent.version === '8.18.0') {
                      tempNodes.push({ id: nextNodeId++, label: 'Upgrade Aria Automation to 8.18.1', type: 'action', x: nodeXPosition });
                      tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                      lastNodeId = tempNodes[tempNodes.length - 1].id;
                      details += `<li>**Upgrade Aria Automation to 8.18.1:** If your Aria Automation is at 8.18.0, you must upgrade to 8.18.1 as an intermediate step.</li>`;
                  }
                  if (ariaAutomationComponent.version === '8.18.0' || ariaAutomationComponent.version === '8.18.1') {
                      tempNodes.push({ id: nextNodeId++, label: 'Upgrade Aria Automation to 9.0.0', type: 'action', x: nodeXPosition });
                      tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                      lastNodeId = tempNodes[tempNodes.length - 1].id;
                      details += `<li>**Upgrade Aria Automation to 9.0.0:** Upgrade your Aria Automation to version 9.0.0.</li>`;
                  }
              }

              // Aria Operations for Logs specific upgrade paths for Converge Path
              if (hasAriaOperationsForLogs) {
                  tempNodes.push({ id: nextNodeId++, label: 'Transition to VCF Operations for Logs 9.0', type: 'action', x: nodeXPosition });
                  tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
                  lastNodeId = tempNodes[tempNodes.length - 1].id;
                  details += `<li>**Transition to VCF Operations for Logs 9.0:** If you have Aria Operations for Logs, you will need to transition to the VCF Operations for Logs 9.0 solution. This is typically a migration or redeployment process, as direct in-place upgrades are often not supported for this component when moving to a new VCF major version. Refer to the specific <a href="https://docs.vmware.com/en/VMware-Cloud-Foundation/services/rn/vmware-vrealize-log-insight-for-vcf-release-notes/index.html" target="_blank" class="text-blue-600 hover:underline">VCF Operations for Logs documentation</a> for detailed transition procedures.</li>`;
              }


              tempNodes.push({ id: nextNodeId++, label: 'Use VCF Installer (Converge to VCF 9.0)', type: 'action', x: nodeXPosition });
              tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
              lastNodeId = tempNodes[tempNodes.length - 1].id;
              details += `<li>**Use VCF Installer (Converge to VCF 9.0):** Use the VCF Installer to converge your existing vSphere infrastructure into a new VCF 9.0 management domain or workload domain. Refer to the <a href="https://techdocs.broadcom.com/us/en/vmware-cis/vcf/vcf-9-0-and-later/9-0/deployment.html" target="_blank" class="text-blue-600 hover:underline">VCF 9.0 Deployment Guide</a>.</li>`;
          }
          tempNodes.push({ id: nextNodeId++, label: 'Perform Post-Converge/Import Validations', type: 'action', x: nodeXPosition });
          tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
          lastNodeId = tempNodes[tempNodes.length - 1].id;
          details += `<li>**Perform Post-Converge/Import Validations:** After deployment or import, ensure all VCF services are running correctly, perform health checks, and integrate any remaining components or third-party solutions.</li>
          </ol>`;
      }

      // Only add the final VCF 9.0 Environment node if it's NOT a VxRail scenario with no direct upgrade.
      if (!hasVxRail7x && !hasVxRail8x) {
          tempNodes.push({ id: nextNodeId++, label: 'VCF 9.0 Environment', type: 'end', x: nodeXPosition });
          tempConnections.push([lastNodeId, tempNodes[tempNodes.length - 1].id]);
      }

      // Calculate Y coordinates for top-to-bottom rendering
      let currentY = verticalSpacing; 
      for (let i = 0; i < tempNodes.length; i++) {
          tempNodes[i].y = currentY;
          currentY += verticalSpacing;
      }

      // Determine min and max Y for the chart scale to ensure all nodes are visible
      const chartPadding = 50; // Extra padding for visibility
      const chartMinY = tempNodes.length > 0 ? tempNodes[0].y - chartPadding : 0;
      const chartMaxY = tempNodes.length > 0 ? tempNodes[tempNodes.length - 1].y + chartPadding : verticalSpacing * 2;

      overviewDiv.innerHTML = `<p class="text-gray-700">${details}</p>`;

      // Destroy existing chart and clear canvas
      if (window.flowchartInstance) {
        window.flowchartInstance.destroy();
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      }

      // Set canvas dimensions explicitly before creating chart
      const canvas = document.getElementById('flowchart');
      const containerWidth = chartContainer.clientWidth;
      const calculatedChartHeight = chartMaxY; 
      canvas.width = containerWidth;
      canvas.height = calculatedChartHeight; 

      // Adjust chart container's min-height to fit the canvas if needed
      chartContainer.style.minHeight = `${calculatedChartHeight + 40}px`; // Add some extra padding for the container itself

      // Prepare Chart.js data
      const datasets = [
        {
          label: 'Nodes', // Nodes dataset first
          data: tempNodes.map(node => ({ x: node.x, y: node.y, id: node.id, label: node.label, type: node.type })),
          backgroundColor: (context) => {
            // Ensure context.raw and context.raw.type exist before accessing
            if (context.raw && context.raw.type) {
                const type = context.raw.type;
                // Revert to original solid colors
                if (type === 'start') return '#00A300';
                if (type === 'action') return '#007CBB';
                if (type.includes('end')) return '#EF4444';
            }
            return '#56687a'; // Default gray
          },
          borderColor: (context) => {
            // Ensure context.raw and context.raw.type exist before accessing
            if (context.raw && context.raw.type) {
                const type = context.raw.type;
                if (type === 'start') return '#007000';
                if (type === 'action') return '#00568c';
                if (type.includes('end')) return '#B91C1C';
            }
            return '#56687a'; // Default gray border
          },
          pointRadius: 12, 
          pointHoverRadius: 15,
          pointBorderWidth: 2, 
          pointBackgroundColor: 'white'
        },
        {
          label: 'Connections', // Connections dataset second
          data: tempConnections.flatMap(conn => {
            const startNode = tempNodes.find(node => node.id === conn[0]);
            const endNode = tempNodes.find(node => node.id === conn[1]);
            if (startNode && endNode) {
              return [
                { x: startNode.x, y: startNode.y, id: `conn-${conn[0]}-${conn[1]}-start` },
                { x: endNode.x, y: endNode.y, id: `conn-${conn[0]}-${conn[1]}-end` }
              ];
            }
            return [];
          }),
          type: 'line',
          borderColor: '#56687a',
          borderWidth: 2, // Reverted thickness for lines
          pointRadius: 0,
          fill: false,
          tension: 0
        }
      ];

      try {
        window.flowchartInstance = new Chart(ctx, {
          type: 'scatter',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { display: false, min: 0, max: 400 },
              y: { display: false, min: chartMinY, max: chartMaxY, reverse: true } /* Key change for top-to-bottom flow */
            },
            plugins: {
              legend: { display: false },
              datalabels: {
                color: 'white',
                font: { size: 12, weight: 'bold' },
                formatter: (value, context) => {
                  // Only apply formatter for 'Nodes' dataset
                  if (context.dataset.label === 'Nodes') {
                    const node = tempNodes.find(n => n.id === value.id);
                    if (node) {
                        const label = node.label;
                        const maxCharsPerLine = 100; 
                        let wrappedLabel = '';
                        let currentLine = '';
                        const words = label.split(' ');

                        for (let i = 0; i < words.length; i++) {
                            const word = words[i];
                            if ((currentLine + (currentLine ? ' ' : '') + word).length > maxCharsPerLine && currentLine.length > 0) {
                                wrappedLabel += (wrappedLabel ? '\n' : '') + currentLine;
                                currentLine = word;
                            } else {
                                currentLine += (currentLine ? ' ' : '') + word;
                            }
                        }
                        wrappedLabel += (wrappedLabel ? '\n' : '') + currentLine;
                        return wrappedLabel;
                    }
                  }
                  return ''; // Return empty string for non-node datasets
                },
                align: 'center',
                anchor: 'center',
                backgroundColor: (context) => {
                    // Only apply background color for 'Nodes' dataset
                    if (context.dataset.label === 'Nodes' && context.raw && context.raw.type) {
                        const type = context.raw.type;
                        // Revert to original solid colors
                        if (type === 'start') return '#00A300'; 
                        if (type === 'action') return '#007CBB'; 
                        if (type.includes('end')) return '#EF4444'; 
                    }
                    return '#56687a'; // Default gray for nodes, or fully transparent for others
                },
                borderRadius: 6,
                padding: 10,
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const node = tempNodes.find(n => n.id === context.raw.id);
                    if (node) {
                      if (node.type === 'start') return `Current Environment: ${node.label.replace('Current: ', '')}`;
                      if (node.type === 'action') return `Action: ${node.label}`;
                      if (node.type === 'end') return `Target: ${node.label}`;
                    }
                    return '';
                  }
                }
              }
            },
            animation: {
              duration: 800,
              easing: 'easeOutQuart',
              onComplete: () => {
                chartContainer.classList.remove('loading');
              }
            }
          }
        });
        showMessage('Upgrade path generated successfully!');
      } catch (error) {
        console.error('Error rendering flowchart:', error);
        overviewDiv.innerHTML += `<p class="text-red-600">Failed to render flowchart. Please check console for errors: ${error.message}</p>`;
        chartContainer.classList.remove('loading');
        showMessage('Failed to generate flowchart.', 'error');
      }
    }

    // Event listener for export PDF button
    const exportPdfButton = document.getElementById('export-pdf-button');
    exportPdfButton.addEventListener('click', async () => {
        // Add a loading indicator
        showMessage('Generating PDF...', 'info');
        const chartContainer = document.getElementById('chart-container');
        chartContainer.classList.add('loading'); // Reuse chart loading indicator for visual feedback

        const flowchartCanvas = document.getElementById('flowchart');
        const overviewContent = document.getElementById('overview');

        try {
            // Ensure the canvas is rendered before capturing
            if (!window.flowchartInstance) {
                showMessage('Please generate an upgrade path first.', 'error');
                return;
            }

            // Capture the chart canvas
            const chartImgData = flowchartCanvas.toDataURL('image/png');

            // Capture the overview div content
            const overviewCanvas = await html2canvas(overviewContent, {
                scale: 2, // Increase scale for better quality
                useCORS: true, // Important for images if any (though we don't have external images here)
                logging: false // Disable logging for cleaner console
            });
            const overviewImgData = overviewCanvas.toDataURL('image/png');

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4'); // Portrait, millimeters, A4 size

            const pdfWidth = doc.internal.pageSize.getWidth();
            const pdfHeight = doc.internal.pageSize.getHeight();
            const margin = 10; // mm

            // Add title
            doc.setFontSize(20);
            doc.text('VMware VCF 9 Upgrade Path', pdfWidth / 2, margin + 10, { align: 'center' });

            let currentY = margin + 30; // Starting Y position after title

            // Add Chart Image
            const chartImgProps = doc.getImageProperties(chartImgData);
            const chartImgWidth = pdfWidth - 2 * margin;
            const chartImgHeight = (chartImgProps.height * chartImgWidth) / chartImgProps.width;
            
            // Check if chart fits on first page, otherwise add new page
            if (currentY + chartImgHeight > pdfHeight - margin) {
                doc.addPage();
                currentY = margin;
            }
            doc.addImage(chartImgData, 'PNG', margin, currentY, chartImgWidth, chartImgHeight);
            currentY += chartImgHeight + 10; // Add some spacing

            // Add Overview Content Image
            const overviewImgProps = doc.getImageProperties(overviewImgData);
            const overviewImgWidth = pdfWidth - 2 * margin;
            const overviewImgHeight = (overviewImgProps.height * overviewImgWidth) / overviewImgProps.width;

            // Check if overview fits on current page, otherwise add new page
            if (currentY + overviewImgHeight > pdfHeight - margin) {
                doc.addPage();
                currentY = margin;
            }
            doc.addImage(overviewImgData, 'PNG', margin, currentY, overviewImgWidth, overviewImgHeight);
            currentY += overviewImgHeight + 10;

            doc.save('VCF_Upgrade_Path.pdf');
            showMessage('PDF generated successfully!', 'success');

        } catch (error) {
            console.error('Error generating PDF:', error);
            showMessage('Failed to generate PDF. Please check console for errors.', 'error');
        } finally {
            chartContainer.classList.remove('loading');
        }
    });


    // Initialize empty state on load
    window.onload = () => {
      const overviewDiv = document.getElementById('overview');
      overviewDiv.innerHTML = '<p class="text-gray-700">Drop components into "Your Current Environment" and click "Show Upgrade Path".</p>';
      const ctx = document.getElementById('flowchart').getContext('2d');
      if (window.flowchartInstance) {
          window.flowchartInstance.destroy();
      }
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    };
  </script>
</body>
</html>
